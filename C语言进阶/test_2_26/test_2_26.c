#include <stdio.h>
// 有符号类型的整型提升‌：对于有符号类型（如signed char、signed short），其值会被符号扩展为int类型。如果原类型的最高位是1，则在扩展后的int类型中，高位全部补1；如果最高位是0，则高位全部补0‌
// 无符号类型的整型提升‌：对于无符号类型（如unsigned char、unsigned short），其值会被零扩展为int类型，即高位全部补0‌

// 数据的存储

// 数值一样但是在内存里存储的不一样
//  int main(){
//      int a=10;
//      float f=10.0;
//  }

// int main(){

//     return 0;
// }

// 空类型 通常用于函数的返回类型、函数参数、指针类型
// 想明确指定没有参数就指定一个void,表示这个函数无参,就会在调用的时候报
//  void test(void){
//      printf("hehe\n");
//  }
//  int main(){
//      test(100);
//      return 0;
//  }

// 判断字节在内存中是大端存储还是小端存储,写一段代码告诉我们当前机器的字节序是什么
// 小端存储:就是低位放在低地址,高位放在高地址. 例如:0x01 00 00 00 这是1在内存中的存储方式小端存储
// 大端存储,就是高位放在低地址,低位放在高地址. 例如:0x00 00 00 01 这是1在内存中的存储方式大端存储
//  int main()
//  {
//      int a = 1;
//      char* p=(char*)&a;
//      if(*p==1){
//          printf("小端存储\n");
//      }
//      else
//      {
//          printf("大端存储\n");
//      }

//     return 0;
// }

// 把其封装成一个函数 就不用打印,谁要用就谁调用,返回个1或者0就可以了,这样交互性更高.
// 方法1:(可简化)
// int check_sys()
// {
//     int a = 1;
//     char *p = (char *)&a;
//     if (*p==1)
//     {
//         return 1;
//     }
//     else
//     {
//         return 0;
//     }
// }
// 方法2(还可简化)
// int check_sys()
// {
//     int a = 1;
//     char *p = (char *)&a;
//     //小端返回1
//     //大端返回0
//     return *p;
// }
// //方法3:
// int check_sys()
// {
//     int a = 1;
//     //直接强制类型转换之后解引用,少去了存储在*p的这一步
//     return *(char *)&a;
// }
// int main()
// {
//     int ret = 0;
//     ret = check_sys();
//     if (ret == 1)
//     {
//         printf("小端存储\n");
//     }
//     else
//     {
//         printf("大端存储\n");
//     }

//     return 0;
// }

// 输出什么
//  int main(){
//      char a=-1;
//      //10000000000000000000000000000001 原码
//      //11111111111111111111111111111110 反码
//      //11111111111111111111111111111111 补码
//      //11111111 char只能放8位
//      //因为打印出来的时候是%d为整形.要进行整形提升补齐32位,高位是1,所以要补1.补完补码还是全1,所以a和b都一样
//      signed char b=-1;
//      //有符号为的负一则输出-1
//      unsigned char c=-1;
//      //然而到unsigned char打印的时候高位不是符号位,是无符号位,所以提升的时候高位补0.再打印的时候高位是0 是正数,就是255
//      //000000000000000000000000011111111

//     // 10000001 --原码
//     // 11111110 --反
//     // 11111111 --补  无符号的负一那就是说明所有都是有效位 所以就是255
//     printf("a=%d,b=%d,c=%d\n",a,b,c);
// }

// int main(){
//     char a=-128;
//     //1000000000000000000000000 1000 0000 原
//     //1111111111111111111111111 0111 1111 反
//     //1111111111111111111111111 1000 0000 补

// 128
//      //1111111111111111111111111 1000 0000 原
//      //1000000000000000000000000 0111 1111 反
//      //1111111111111111111111111 1000 0000 补 和-128一样 所以打印出来的值一样

//     //1000 0000
//     //%u就是打印十进制的无符号数
//     //%d就是打印十进制的有符号数
//     //1111111111111111111111111 1000 0000
//     //整形提升后的结果,还是跟补码一样.正常来说要求出原码打印,但是这里要打印的是无符号数,那么原反补相同,所以就直接求.其十进制就是4294967168
//     printf("%u\n",a);
//     return 0;
// }
// 不管正负两题输出结果一样 因为127过去后就是-128在有符号数的情况下
// int main(){
//         char a=128; //127+1  0111 1111->1000 0000 =-128 所以输出的值都一样
//         printf("%u\n",a);
//         return 0;
//     }

//-128:
// 100000000000000000000000  1000 0000
// 111111111111111111111111  0111 1111
// 111111111111111111111111  1000 0000再截断之后和原码一样所以就规定为-128
//+128
// 000000000000000000000000 1000 0000(原反补) 截断后与-128结果都一样所以他们输出的结果都一样

// 对于1000 0000 在内存中存储的时候直接规定为-128
// 无符号位的直接是0-255
// 0000 0000
// 0000 0001
// 0000 0010
//       ...
// 0111 1111
// 1000 0000 (补)没办法向高位借位了,因为第一位是符号位,但是直接翻译成-128.
// 因为假设不用32个比特位,用9个比特位来讨论,最高位是符号位
//     1 1000 0000 -128原码
//     1 0111 1111 反
//     1 1000 0000 补 发现和内存中存的原1000 0000一摸一样, 所以直接规定为-128
//  所以有符号的char 最小是-128,最大是127.

// 1000 0001 (补)->1000 0000 (反)-> 1111 1111(原) -127
// 1000 0010
//     ...
// 1111 1101 (补) -> -2
// 1111 1111 (补) ->11111110(反)->10000001(原) -1

// int main(){
//     int i=-20;
//     unsigned int j=10;
//     printf("%d\n",i+j);
//     // 10000000 00000000 00000000 0001 0100 原
//     // 11111111 11111111 11111111 1110 1011 反
//     // 11111111 11111111 11111111 1110 1100 补
//     // 00000000 00000000 00000000 0000 1010 原反补
//     // 11111111 11111111 11111111 1111 0110 相加的补码
//     // 11111111 11111111 11111111 1111 0101 反
//     // 10000000 00000000 00000000 0000 1010 原 -10
// }

// #include <unistd.h>
// int main(){
//     unsigned int i;//因为无符号数最小也是0,而底下for循环的判断条件也是>=0的 所以进去就是死循环了
//     for ( i = 9; i>=0; i--)
//     {
//         printf("%u\n",i);
//         sleep(1);//1秒打印一个
//     }
//     //0000 1001 9
//     //0000 1000 8
//     //0000 0111 7
//     //0000 0110 6
//     //0000 0101 5
//     //0000 0100 4
//     //0000 0011 3
//     //0000 0010 2
//     //0000 0001 1
//     //0000 0000 0
//     //1111 1111 -1(是无符号数,那么就是1) 32位都是1 然后再上来循环2^32次方...一直死循环

//     return 0;
// }

// int main(){
//     //a0=-1 a1=-2...-128 a127=-128 a128=127....0  从-1一直减到-128,-128再减1就得到127,直到0.而0的ASCII码值是0,strlen遇到斜杠0就跳出.
//     char a[1000];
//     int i;
//     for (size_t i = 0; i < 1000; i++)
//     {
//         a[i]=-1-i;
//     }
//     printf("%d",strlen(a));
//     return 0;
// }

// unsigned char i=0;
// //输出结果死循环 无符号范围永远是char0-255,当i到255+1就是256开始死循环.
// int main(){
//     for ( i = 0; i <=255; i++)
//     {
//         printf("hello world\n");
//     }
//     return 0;
// }

// 浮点数的存储
//  #include <limits.h> //查看整形存储的范围
//  #include <float.h>  //查看浮点型存储的范围
//  int main(){
//      double d=1E10;
//      printf("%lf\n",d);
//      return 0;
//  }

// 浮点型和整形存储的区别  IEEE754规定 首先把一个浮点数从十进制转向二进制,再写成这种科学记数法的形式
// 浮点型存储    -1^S*M*2^E  (-1)^s表示符号位.当s=0,v为正数;当s=1,v为负数.
// M表示有效数字,大于等于1,小于等于2
// 2^E表示指数位

// 9.0
// 1001.0
//(-1)^0*1.001*2^3
//(-1)^s*  M*  2^E

// 十进制向二进制转换 <10的数E则会产生负数 但是通过IEEE规则加上127后也可以求出为正数
// 0.5十进制.他的二进制形式是0.1    0的权重是2的0次方,而.1的权重是2的负一次方,所以当把0十进制的0.5转换成二进制的0.1的时候就是二进制的表现形式了
// 1.0(写成科学计数法) 就把0.5改成1.0乘多少来表示 这边就是再乘2^-1 ,  1.0*2^-1  当十进制的数小于1的时候就回产生E为负数.
//(-1)^0*1.0*  2^-1  E此时为-1,但在IEEE规定E得是无符号位的数,所以得加个127
//  E=-1
// E+127=126
// S=0
// M=1.0

// 然后3.14的话就难算  小数点前面 11.001 小数点后面 小时2^-3=0.125但是和0.14还差点数值,所以后面得补若干个0和1的组合才能精确匹配到0.14,但是很难, 11.001(010101001001)

int main()
{
    int n = 9;
    // 放进去是按照整形的规则放进去的  所以和下方float5.5放进去的规则不一样,所以这边的9在低位,而float 5.5的 011在高位
    // 0 00000000 00000000000000000001001 --补

    float *pFloat = (float *)&n;
    printf("n的值为:%d\n", n);
    printf("*pFloat的值为:%f\n", *pFloat); // 0.000000
    //(-1)^0 * 0.00000000000000000001001 * 2^-126

    *pFloat = 9.0;
    // 1001.0此时这里又是按照浮点数存了
    // s=0
    // M=1.0010(科学记数法的表现形式) (1001.0)小数点向右移动了3位  M补齐23位小数点后开始 00100000000000000000000
    // E=3(移动3位)  3+127=130  换算成二进制就是 1000 0010
    // 放一块 0  10000010 00100000000000000000000
    // 存进去内存里就是 0100 0001 0001 0000 0000 0000 0000 0000
    // 0x41100000 内存里面转换成16进制
    // 按照十进制取出来
    // 0100 0001 0001 0000 0000 0000 0000 0000 (正数原反补相同)=1091567616
    // 取出来就是 (-1)^0 * 1.0010*2^3  这里面由于9.0后面的.0时正数,所以移动的位数3就不用再乘负数次方转换为具体几点几的小数了
    printf("n的值为:%d\n", n); // 1091567616
    printf("*pFloat的值为:%f\n", *pFloat);
    return 0;
}

// int main(){
//     float f=5.5;
//     //32位s占一位  E占8位 M占23位
//     // 101.1  小数点前面101,小数点后面0.5转换成二进制1  2的-1次方就是2分之一0.5
//     //(-1)^0*1.011*2^2(小数点向右移动两位就乘2次方)
//     //S=0;
//     //M=1.011
//     // E=2   2+127
//     //对于32位浮点数
//     //s是0
//     //E是2(小数点向右移动了两位101.1->1.011) ,加上中间值127就是129,写成二进制虚列 10000001
//     //M是23位的比特位,这边只写出了3位011,要补齐01100000000000000000000,因为开头的1会省略掉,这样可以提高精度
//     //放一块就是 0100 0000 1011 0000 0000 0000 0000 0000
//     //0x40b00000
//     //存进去就是 0100 0000 1011 0000 0000 0000 0000 0000

//     //取出来(E不为全0或者全1的时候)E-127或者1023
//     // 由于正数部分刚刚011放进去的时候省略了1,取出来的时候要补上为1.011

//     //E为全0时,说明加了127时还是0说明原数值可能是-127
//     //(-1)^0 * 1.xxx *2^-127  那么2的负127次方就是2的127次方分之一几乎接近于0就是几乎不存在的数字
//     //所以假设全0时,浮点数(1-127)或1023即为真实值,有效数字M不再加上第一位的1,而是还原为0.xxxxx的小树,这样做是为了表示正负0以及接近0的的很小的数字
//     //即+/-0.011*2^-126

//     //E为全1时
//     //0 11111111 01100000000000000000000
//     //E+127=255
//     //E=128
//     //1.xxx*2^128
//     //表示的是正负无穷大的数字

//     return 0;
// }
